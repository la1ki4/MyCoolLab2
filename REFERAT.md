# Реферат "Методы сортировки"

## Оценка сложности алгоритмов

Прежде чем переходить непосредтвенно к самим __алгоритмам сортировки__, я считаю необходимым сначало пройтись __по оценки сложности алгоритмов__. Стоит понимать, что если просто запустить алгоритм на двух разных комьютерах с разными процессорами, то один и тот же алгоритм может выполнится за разное количество времени. Поэтому сложность алгоритмов, как правило, оценивают по количеству операций в алгоритме, и по объёму памяти, который расходует алгоритм. Для этого используется нотация __Big O__, которая гласит, что от __передаваемых параметров__ зависит __количество операций__, которые будут выполнены перед тем, как алгоритм завершится. 

![alt text](./big-o-chart-tutorial-bazar-aymptotic-notations-1.png)

Из данной нотации видно, что быстрее всего растёт время выполнения алгоритма с количеством операций _O($N!$)_ __(факториальная сложность)__. Из чего вытекает, что алгоритм с количеством операций _O($N!$)_ будет выполнятся долго, и наоборот алгоритм с количеством операций _O(1)_ __(константная сложность)__ будет выполняться быстро. 

### __Константная сложность__ _O(1)_:

Констатная сложность подразумевает, что __код всегда выполняется за одно и то же время, и никаким образом не зависит от размера входных данных.__
Например в цикле _for_ мы перебираем константное число 100. Следовательно алгоритм всегда сделает не более, чем 100 шагов перед тем, как выполниться.

 __Пример:__
```
void someFunction()
{
    for(unsigned short i = 0; i < 100; i++)
    {
        //...
    }
}
```

### __Линейная сложность__ _O(N)_:
Линейная сложность подразумевает, что __код зависит от входного параметра N, который будет подставлен в цикл как кол-во шагов, которое должно выполнится.__ Например в цикле _for_ N = 10, тогда цикл выполниться не более, чем в 10 шагов, или если N = 100, тогда цикл выполнется не более, чем в 100 шагов. __Пример:__

```
void someFunction(const unsigned short& N)
{
    for(unsigned short i = 0; i < N; i++)
    {
        //...
    }
}
```
_Сублинейная сложность_ _O($\sqrt{N}$)_

Стоит упомянуть, что не каждый алгоритм является линейным. Необходимо работу своего алгоритма хотя бы немного представлять у себя в голове. Например в качестве параметра N мы передаём число 81, и запустим цикл _for_, который выглядит следующим образом:
```
void someFunction(const unsigned short& N)
{
    // N == 81
    for(unsigned short i = 1; i*i <= N; i++)
    {
        //...
    }
}
```
В таком случае цикл отработает не более чем $\sqrt{81}$ раз, то есть 9 раз. При N = 121 цикл отработает не более, чем 11 раз, при N = 144 цикл отработает не более, чем 12 раз и т.д. 

### __Атомарные языковые операции__

Попробуем усложнить задачу, добавив перед циклом добавление переменной a = 1, и попробуем после отработки цикла _for_ инкрементировать переменную a. 

 __Пример:__
```
void someFunction(const unsigned short& N)
{
    short a = 1;

    for(unsinged short i = 0; i < N; i++)
    {
        //...
    }

    a++;
}
```
В таком случае сложность даного алгоритма будет составлять _O(1+N+1)_, поскольку в функции someFunction существует две атомарных языковых операций в виде инициализации переменной a, и её инкрементации. Однако при общей оценки сложности алгоритмов константные значения отбрасываются, поскольку они не способны оценить общую сложность алгоритма, и отброшенные константы связаны лишь с временем выполнения алгоритма и не имеют принципиального значения при качественном сравнении сложности алгоритмов. Таким образом сложность данного алгоритма составляет _O(N)_ __(линейная сложность)__. Из чего вытекает,что если у нас есть например два алгоритма со сложностью _O(N+100)_ и _O(5*N)_, тогда они будут равны между собой, поскольку отбросив константные значения эти 2 алгоритма будут иметь сложность _O(N)_ __(линейная сложность).__

### __Множество аргументов__

Если алгоритм зависит более, чем от одного аргумента, то мы должны указать их все. Например наш алгоритм работает с аргументами N и K. Следовательно в общей оценки сложности алгоритма мы должны указать оба этих аргумента.

__Пример 1:__
```
void someFunction(const unsigned short& N, const unsigned short& K)
{
    for(unsigned short i = 0; i < N; i++)
    {
        //...
    }

    for(unsigned short i = 0; i < K; i++)
    {
        //...
    }
}
```
В данном случае сложность алгоритма составляет _O(N+K)_, поскольку отдельно друг от друга выполняется 2 цикла, где первый цикл отрабатывает до N шагов, а второй цикл отрабатывает до K шагов.

__Пример 2:__
```
void someFunction(const unsigned short& N, const unsigned short& K)
{
    
    for(unsigned short i = 0; i < N; i++)
    {
        //...
        for(unsigned short j = 0; j < K; j++)
        {
            //...
        }
    }
}
```

В данном случае сложность алгоритма составляет _O(N*K)_, поскольку итерация цикла с N-ым количеством шагов зависит от работы цикла с K-ым количеством шагов. Следовательно пока вложенный цикл не завершит свою работу, цикл, который находится выше, не сделает сдвиг. Прямо как часы,минутная стрелка не сдвинется, пока секундная стрелка не выполнит полный оборот :)

### __Квадратичная сложность O($N^2$)__

Данная сложность возникает в том случае, когда количество аргументов равняется одному, и количество шагов во вложенном цикле равняется количетсву шагов в цикле выше

__Пример:__
```
void someFunction(const unsigned short& N)
{
    for(unsigned short i = 0; i < N; i++)
    {
        for(unsigned short j = 0; j < N; j++)
        {
            //...
        }
    }
}
```

При этом нужно понимать, что степень у N не обязательно может быть 2. Она может равнятся и 3 и 4 и т.д. в зависимости от того, сколько циклов вложенно друг в друга. 

При этом может возникнуть такой случай, что сложность алгоритма может достигнуть и до _O($N^2$ + $N$)_. Во время подобных сложений стоит понимать, что мы всегда ищем худшую временную сложность, а потому сравнивая алгоритмы, наша задача получить не конкретные значения, а смотреть как растёт время выполнения при росте входных данных. Поэтому +$N$ можно смело откинуть, и это абсолютно ни на что не повлияет _O($N^2$ + $N$)_ = _O($N^2$)_

### __Логарифмическая сложность O($log N$)__

Можно рассмотреть как работает бинарный поиск в отсортированном массиве:
```
int binarySearch(std::vector<int>& arr, const int& searchData)
{
    int left = 0;
    int right = arr.size() - 1;
    while(left <= right)
    {
        int mid = (right - left) / 2;
        if(arr.at(mid) == searchData)
        {
            return arr.at(mid);
        }
        else if(arr.at(mid) > searchData)
        {
            left = mid - 1;
        }
        else
        {
            right = mid + 1;
        }
    }

    return -1;
}

int main()
{
    std::vector<int> arr = {0,1,2,3,5,5,6,7};
    int searchData = 4;
    std::cout << binarySearch(arr,searchData) << std::endl;
}
```

В данном примере в массиве хранится 8 элементов, и при поиске нужного нам элемента мы постоянно будем делить отрезок на половину. Мы можем заметить, что в массиве с 8 элементами для поиска нам пришлось совершить 4 шага, для массива с 4мя элементами 3 шага, для массива с 2мя элементами 2 шага и т.д. Таким образом мы получаем следующие значения для текущих операций:

$log{_2}{8}$ + 1 = 4

$log{_2}{4}$ + 1 = 3

$log{_2}{2}$ + 1 = 2

И в общем случае получается следующая сложность $log{_2}{N}$ + 1, и 
если отбросить константы, то наихудший случай будет выглядить следующим образом $log{N}$.

### __Экспоненциальная сложность O($2^N$)__
Далее перейдём ещё к более сложной задачи, взяв задачу с вызовом двух рекурсивных функций

```
int someFunction(const int& N)
{
    if(N == 1)
    {
        return 1;
    }
    return someFunction(N - 1) + someFunction(N - 1);
}
```

В данном случае для n = 3 количество рекурсивных вызовов будет равно 7, для n = 4 количество рекурсивных вызовов будет равно 15,а для n = 5 количество рекурсивных вызовов будет равно 31. Из этого следует следующая формула $2^N - 1$. Тогда сложность алгоритма будет достигать O($2^N - 1$), и если отбросить все константы, то общая сложность алгоритма составляет O($2^N$) __(экспоненциальная сложность)__.




## __Сортировка пузырьком (Bubble sort)__
Теперь когда разобрались со сложностями алгоритмов, можно непосредственно перейти к алгоритмам сортировки.

Сортировка пузырьком является одним из простейших алгоритмов сортировки. Его суть заключается в том, что мы пробегаемся по массиву от нулевого элемента до самого последнего, попутно меняя местами два неотсортированных элемента. В результате первого обхода массива самый последний элемент будет являться самым максимальным, что позволит уменьшить границу повторного обхода на 1 элемент в массиве. Сортировка будет считаться законченной, когда при очередном обходе все элементы будут отсортированны. Полезна данная сортировка при небольшом объёме данных в массиве. Количество операций в наихудшем случае составляет _O($N^2$)_ __(квадратичная сложность)__, а в лучшем случае _O($N$)_ __(линейная сложность)__. Затраты по памяти составляет _O(1)_ __(константная сложность)__.

**Код:**
```
void bubbleSort(std::vector<int>& arr)
{
    for (size_t i = 0; i < arr.size(); i++)
    {
        bool isSorted = true;
        for (size_t j = 0; j < arr.size() - (i + 1); j++)
        {
            if (arr.at(j) > arr.at(j + 1))
            {
                isSorted = false;
                std::swap(arr.at(j + 1), arr.at(j));
            }
        }
        if (isSorted)
        {
            break;
        }
    }
}
```

## __Сортировка вставкой (Insertion sort)__

Сортировка вставкой всё так же является простым алгоритмом сортировки. Его суть заключается в том, что мы условно делим массив на две части: _"отсортированная часть"_ и _"неупорядочная часть"_. Мы предполагаем, что нулевой элемент в массиве уже отсортирован. Далее берём следующий по счёту элемент, и сравниваем его уже с _"отсортированной частью"_, попутно искав для него место, в которое можно поставить этот самый элемент в _"отсортированную часть"_. Перебираем каждый последующий элемент из _"неупорядочной части"_ до тех пор, пока в _"неупорядочной части"_ не останется ни одного элемента. Количество операций в наихудшем случае составляет _O($N^2$)_ __(квадратичная сложность)__, а в лучшем случае _O($N$)_ __(линейная сложность)__. Затраты по памяти составляет _O(1)_ __(константная сложность)__.

**Код:**
```
void insertionSort(std::vector<int>& arr)
{
    for (size_t i = 1; i < arr.size(); i++)
    {
        for (size_t j = i; j > 0 && arr.at(j - 1) > arr.at(j); j--)
        {
            std::swap(arr.at(j - 1), arr.at(j));
        }
    }
}
```

## __Сортировка выбором (Selection sort)__

Сортировка выбором так же является простым алгоритмом сортировки. Его суть заключается в том,что как и в случае с сортировкой вставкой, мы делим массив на две части: _"отсортированная часть"_ и _"неупорядочная часть"_. Только в случае с сортировкой вставкой мы делали нулевой элемент в массиве уже отсортированным, и из _"неупорядочной части"_ массива мы брали каждый элемент, и искали для него место в _"отсортированной части"_. В случае же с сортировкой выбором, мы из _"неупорядочной части"_ выбираем самый максимальный элемент, и меняем местами с последним элементом в массиве, создавая _"отсортированную часть"_ прямо с конца,фиксируя позицию, на котором расположился максимальный элемент в массиве. Ищем на каждой итерации самый максимальный элемент из _"неупорядочной части"_, и меняем местами с последним элементом из _"неупорядочной части"_,уменьшая размер этой самой части на один элемент, фиксируя позицию данного максимального элемента. Количество операций в любых случаях составляет _O($N^2$)_ __(квадратичная сложность)__. Затраты по памяти составляет _O(1)_ __(константная сложность)__.

**Код:**
```
void selectionSort(std::vector<int>& arr)
{
    for (size_t i = 0; i < arr.size(); i++)
    {
        for (size_t j = i + 1; j < arr.size(); j++)
        {
            if (arr.at(j) < arr.at(i))
            {
                std::swap(arr.at(i), arr.at(j));
            }
        }
    }
}
```


